/*
 * @author: Lander Buysse
 * @file: inputControl.c
 */

//files to include
#include "inputControl.h"
#include "stdio.h"
#include "joystickDriver.h"
#include "buttonDriver.h"
#include "MK64F12.h"
#include "main.h"

//variables
timeParts timePart;
changeState selectState;
int hour_time=0;
int min_time=0;
int sec_time=0;
int alarmOnOff=0;

/*
 * initialise the joystick and some variables
 */
void initJoystick(void){
	timePart=HOUR_I;
	selectState=STANDARD_I;
	joystickInit();
}

/*
 * initialise switch 2
 */
void initSwitch2(void){
	SW2Init();
}

/*
 * returns the hour from the state set time
 */
int getHour(void){
	return hour_time;
}

/*
 * returns min from the state set time
 */
int getMin(void){
	return min_time;
}

/*
 * returns sec from the state set time
 */
int getSec(void){
	return sec_time;
}

/*
 * returns the string to be displayed when choosing to change a setting
 */
char * getSetting(int setting){
	char *str="";
	switch(setting){
		case 0:
			str="Standard";
			break;
		case 1:
			str="Set Time";
			break;
		case 2:
			str="Set Alarm";
			break;
		case 3:
			str="Set Music";
			break;
		default:
			setting=0; //just in case something went wrong
			str="Standard";
		break;
	}
	return str;
}

//setters

/*
 * increment the hour, min or sec when setting the time or the alarm
 */
void incrementTime(int hour_timeMinSec){
	switch(hour_timeMinSec){
		case 0: //increment hour_time
			if (hour_time<23){
				hour_time=hour_time+1;
			}else{
				hour_time=0;
			}
			break;
		case 1: //increment min_time
			if (min_time<59){
				min_time=min_time+1;
			}else{
				min_time=0;
			}
			break;
		case 2: //increment sec_time
			if (sec_time<59){
				sec_time=sec_time+1;
			}else{
				sec_time=0;
			}
			break;
		//TODO case 3,4,5 for the alarm time
		default:
			//do nothing, just in case something went wrong
			break;
	}
}

/*
 * decrement the hour,min or sec when setting the time or the alarm
 */
void decrementTime(int hour_timeMinSec){
	switch(hour_timeMinSec){
			case 0: //decrement hour_time
				if (hour_time>0){
					hour_time=hour_time-1;
				}else{
					hour_time=23;
				}
				break;
			case 1: //increment min_time
				if (min_time>0){
					min_time=min_time-1;
				}else{
					min_time=59;
				}
				break;
			case 2: //increment sec_time
				if (sec_time>0){
					sec_time=sec_time-1;
				}else{
					sec_time=59;
				}
				break;
			//TODO case 3,4,5 for the alarm time
			default:
				//do nothing, just in case something went wrong
				break;
		}
}

/*
 * sets (or resets) the variable that indicates whether the alarm is on or off
 */
void setAlarm(int onOff){
	alarmOnOff=onOff;
}

/*
 * interrupt handler for portc
 * 		handles the actions for joystick left and joystick right
 */
void PORTC_IRQHandler(void){
	switch(getState()){
			case 0: //STANDARD
				//joystick left
				if((PORTC->PCR[LEFT] & 0x01000000)==0x01000000){ //check if interrupt was called on left pin
					if (selectState==0){ //go to the previous option
						selectState=3;
					}
					else{
				        selectState = --selectState % 4;
				    }
					PORTC->PCR[LEFT] &= ~(0 << 24); //clear the interrupt for the left pin
					//TODO: show the selected option
						//=>getSetting(selectState)
				}
				//joystick right
				if((PORTC->PCR[RIGHT] & 0x01000000)==0x01000000){ //check if interrupt was called on right pin
					selectState=++selectState%4; //go to the next option
					PORTC->PCR[RIGHT] &= ~(0 << 24); //clear the interrupt for the right pin
					//TODO: show the selected option
						//=>getSetting(selectState)
				}
				break;
			case 1: //SETTIME
				//joystick left
				if((PORTC->PCR[LEFT] & 0x01000000)==0x01000000){//check if interrupt was called on left pin
					if (selectState==0){ //go to the previous option
						selectState=2;
					}
					else{
						selectState = --selectState % 3;
					}
					PORTC->PCR[LEFT] &= ~(0 << 24); //clear the interrupt for the left pin
				}
				//joystick right
				if((PORTC->PCR[RIGHT] & 0x01000000)==0x01000000){ //check if interrupt was called on right pin
					selectState=++selectState%3; //go to the next option
					PORTC->PCR[RIGHT] &= ~(0 << 24); //clear the interrupt for the right pin
				}
				break;
			case 2: //SETALARM
				//TODO: implement this using the enum for alarm time
				break;
			case 3: //SETMUSIC
				//TODO:implement this, make 5 different music tunes, create enum to select
				//joystick left
					//set previous music tone, clr interrupt
				//joystick right
					//set next music tone, clr interrupt
				break;
			case 4: //ALARM
				//joystick left or right ==> do nothing and clear the interrupts
				if(((PORTC->PCR[LEFT] & 0x01000000)==0x01000000) || ((PORTC->PCR[RIGHT] & 0x01000000)==0x01000000)){
					PORTC->PCR[LEFT] &= ~(0 << 24); //clear the interrupt for the left pin
					PORTC->PCR[RIGHT] &= ~(0 << 24); //clear the interrupt for the right pin
				}
				break;
			default:
				//do nothing and go back to standard, just in case something happened
				setState(0);
				break;
		}

}

/*
 * interrupt handler for portb
 * 		handles the actions for joystick up, joystick down and joystick center
 */
void PORTB_IRQHandler(void){
	switch(getState()){
		case 0: //STANDARD
			if((PORTB->PCR[CENTER] & 0x01000000)==0x01000000){ //check if interrupt was called on CENTER pin
				setState((int)selectState); //go to the selected state
				PORTB->PCR[CENTER] &= ~(0 << 24);  //Clear the interrupt for the CENTER pin
			}
			//nothing needs to happen here for the up and down pins so just clear the interrupts
			if(((PORTB->PCR[UP] & 0x01000000)==0x01000000) || ((PORTB->PCR[DOWN] & 0x01000000)==0x01000000)){
				PORTB->PCR[UP] &= ~(0 << 24);  // clear the interrupt for the up pin
				PORTB->PCR[DOWN] &= ~(0 << 24); //clear the interrupt for the down pin
			}
			break;
		case 1: //SETTIME
			//joystick center
			if((PORTB->PCR[CENTER] & 0x01000000)==0x01000000){ //check if interrupt was called on CENTER pin
				setState(0); //0==STANDARD state
				timePart=0; //Set back to hour_time
				PORTB->PCR[CENTER] &= ~(0 << 24);  //Clear the interrupt for the CENTER pin
			}
			//joystick down
			if((PORTB->PCR[DOWN] & 0x01000000)==0x01000000){ //check if interrupt was called on DOWN pin
				decrementTime(timePart);
				PORTB->PCR[DOWN] &= ~(0 << 24); //clear the interrupt for the DOWN pin
			}
			//joystick up
			if((PORTB->PCR[UP] & 0x01000000)==0x01000000){ //check if interrupt was called on up pin
				incrementTime(timePart);
				PORTB->PCR[CENTER] &= ~(0 << 24);  //clear the interrupt for the UP pin
			}
			break;
		case 2: //SETALARM
			//joystick center
			if((PORTB->PCR[CENTER] & 0x01000000)==0x01000000){ //check if interrupt was called on CENTER pin
				setState(0); //0==STANDARD state
				timePart=0; //Set back to hour_time
				PORTB->PCR[CENTER] &= ~(0 << 24);  //Clear the interrupt for the center pin
			}
			// TODO: separate variable for the alarm???
			//if down ==>decrementTime(getTimeParts), clr interrupt
			//if up ==> incrementTime(getTimeParts), clr interrupt
			break;
		case 3: //SETMUSIC
			//joystick center
			if((PORTB->PCR[CENTER] & 0x01000000)==0x01000000){ //check if interrupt was called on CENTER pin
				setState(0); //0==STANDARD state
				PORTB->PCR[CENTER] &= ~(0 << 24);  //Clear the interrupt for the center pin
			}
			//if down ==>do nothing, clr interrupt
			//if up ==>do nothing, clr interrupt
			break;
		case 4: //ALARM
			//if center ==> alarmOnOff=0;, clr interrupt,
			//state will be changed in main when everything is turned of from the main
			break;
		default:
			setState(0); //go to standard state, just in case something went wrong
			break;
	}

}
